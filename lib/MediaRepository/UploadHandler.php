<?php
/**
 * MediaRepository.
 *
 * @copyright Axel Guckelsberger
 * @license http://www.gnu.org/licenses/lgpl.html GNU Lesser General Public License
 * @package MediaRepository
 * @author Axel Guckelsberger <info@guite.de>.
 * @link http://zikula.de
 * @link http://zikula.org
 * @version Generated by ModuleStudio 0.5.5 (http://modulestudio.de) at Fri Jun 22 18:45:35 CEST 2012.
 */

/**
 * Upload handler implementation class.
 */
class MediaRepository_UploadHandler extends MediaRepository_Base_UploadHandler
{
    // feel free to add your upload handler enhancements here
     /**
     * Process a file upload.
     *
     * @param string $objectType Currently treated entity type.
     * @param string $fileData   Form data array.
     * @param string $fieldName  Name of upload field.
     *
     * @return array Resulting file name and collected meta data.
     */
    public function performFileUpload($objectType, $fileData, $fieldName)
    {
        $dom = ZLanguage::getModuleDomain('MediaRepository');
    
        $result = array('fileName' => '',
                        'metaData' => array());
    
        // check whether uploads are allowed for the given object type
        if (!in_array($objectType, $this->allowedObjectTypes)) {
            return $result;
        }
        
        
        // perform validation
        //This checked to make sure it is an allowed type, not too big and if images, of the right image types.
        if (!$this->validateFileUpload($objectType, $fileData[$fieldName], $fieldName)) {
            // skip this upload field
            return $result;
        }
    
        // retrieve the final file name
        $fileName = $fileData[$fieldName]['name'];
        $fileNameParts = explode('.', $fileName);
        $extension = $fileNameParts[count($fileNameParts) - 1];
        $extension = str_replace('jpeg', 'jpg', strtolower($extension));
        $fileNameParts[count($fileNameParts) - 1] = $extension;
        $fileName = implode('.', $fileNameParts);
    
        
        //Get the repository information and find out where files should be storeed  TDP
        $repository = ModUtil::apiFunc('MediaRepository', 'selection', 'getEntity', array('ot' => 'repository', 'id' => $fileData['repository']));
        
        $basePath = $repository['storageDirectory'];
        //check to make sure last char of string is a slash
        if(substr($basePath, -1) != '/'){
            $basePath .= '/';
        }
        $fileName = $this->determineFileName($objectType, $fieldName, $basePath, $fileName, $extension);
    
        if (!move_uploaded_file($fileData[$fieldName]['tmp_name'], $basePath . $fileName)) {
            return LogUtil::registerError(__('Error! Could not move your file to the destination folder.', $dom));
        }
    
        // collect data to return
        $result['fileName'] = $fileName;
        $result['metaData'] = $this->readMetaDataForFile($fileName, $basePath . $fileName);
    
        return $result;
    }
    
     /**
     * Determines the allowed file extensions for a given object type.
      *  This is dependant upon the repostiory. Right here I have the base class implementation
      * Which is only allowing a few image types. This needs to change I think.
     *
     * @param string $objectType Currently treated entity type.
     * @param string $fieldName  Name of upload field.
     * @param string $extension  Input file extension.
     *
     * @return array the list of allowed file extensions
     */
    protected function isAllowedFileExtension($objectType, $fieldName, $extension)
    {
        // determine the allowed extensions
        $allowedExtensions = array();
        switch ($objectType) {
            case 'mediaHandler':
                $allowedExtensions = array('gif', 'jpeg', 'jpg', 'png');
                    break;
            case 'medium':
                $allowedExtensions = array('gif', 'jpeg', 'jpg', 'png');
                    break;
        }
    
        if (count($allowedExtensions) > 0) {
            if (!in_array($extension, $allowedExtensions)) {
                return false;
            }
        }
    
        if (in_array($extension, $this->forbiddenFileTypes)) {
            return false;
        }
    
        return true;
    }
}
